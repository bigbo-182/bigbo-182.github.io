---
title: "Java 객체 복사 & Cloneable – 면접 대비 핵심 질문 총정리"
date: 2025-12-05
categories: [Java, Interview]
tags: [Java, clone, Cloneable, 얕은복사, 깊은복사]
toc: true
author_profile: false
sidebar:
    nav: "docs"
---

# Java 객체 복사 & Cloneable – 면접 대비 핵심 질문 총정리

자바의 객체 복사, Cloneable, shallow copy, deep copy는  
면접에서 매우 자주 등장하는 개념입니다.  
이 글에서는 **면접에서 바로 답할 수 있는 형태**로 질문과 모범답안을 정리합니다.

---

# ❓ 1. 자바에서 객체를 복사하는 방법은 무엇인가요?

## ✅ 답변 예시
자바에서는 다음과 같은 방식으로 객체를 복사할 수 있습니다:

- `Object.clone()`을 이용한 복사  
- 복사 생성자(Copy Constructor)  
- 정적 팩토리 메서드(copyOf 방식)  
- 직렬화를 활용한 복사  

클래스 설계나 깊은 복사 여부에 따라 적절한 방식을 선택합니다.

---

# ❓ 2. Object.clone() 메서드의 특징은 무엇인가요?

## ✅ 답변 예시
- 자바가 기본 제공하는 복사 메커니즘이며, 동작은 **얕은 복사**입니다.  
- `protected` 접근제어자이므로 외부에서 사용하려면 하위 클래스에서 `public`으로 재정의해야 합니다.  
- Cloneable 인터페이스를 구현하지 않으면 예외가 발생합니다.  
- 실제 복사 작업은 JVM의 native 코드에서 수행됩니다.

---

# ❓ 3. Cloneable 인터페이스는 어떤 역할을 하나요?

## ✅ 답변 예시
Cloneable은 **마커 인터페이스**로, 특별한 메서드를 제공하지 않습니다.  
이 인터페이스를 구현했다는 것은 “이 객체는 복제(clone)를 허용한다”는 의미입니다.  
JVM이 clone 실행 시 이 인터페이스 구현 여부를 확인하여 복제 가능 여부를 결정합니다.

---

# ❓ 4. 얕은 복사(shallow copy)란 무엇인가요?

## ✅ 답변 예시
얕은 복사는 **객체의 필드 값을 그대로 복사하는 방식**입니다.  
단, 내부에 참조 타입이 있을 경우 **그 참조값(주소)을 그대로 복사**하기 때문에  
원본과 복제본이 **같은 내부 객체를 공유**하게 됩니다.  
그래서 복제본의 내부 상태를 변경하면 원본이 영향을 받을 수 있습니다.

---

# ❓ 5. 깊은 복사(deep copy)란 무엇인가요?

## ✅ 답변 예시
깊은 복사는 객체가 가진 **모든 참조 타입 필드까지 새로운 객체로 생성하여 복사하는 방식**입니다.  
즉, 원본과 복사본이 **어떤 객체도 공유하지 않는 완전 독립적인 구조**를 갖습니다.  
원본 변경이 복제본에 전혀 영향을 미치지 않습니다.

---

# ❓ 6. clone()을 override해야 하는 이유는 무엇인가요?

## ✅ 답변 예시
- Object.clone()은 protected이기 때문에 외부에서 호출할 수 없습니다.  
- 따라서 필요한 클래스에서 clone을 public으로 재정의해야 합니다.  
- 또한 가변 객체를 포함한 클래스라면 여기에서 deep copy를 직접 구현해야 합니다.

---

# ❓ 7. String은 왜 얕은 복사여도 안전한가요?

## ✅ 답변 예시
String은 **불변 객체(immutable)**입니다.  
즉, 한 번 생성된 문자열은 내부 값이 절대 변경되지 않습니다.  
따라서 참조를 공유해도 내부 상태가 변할 수 없어 원본이 오염될 가능성이 없습니다.

---

# ❓ 8. 얕은 복사가 위험한 상황은 어떤 경우인가요?

## ✅ 답변 예시
내부에 **가변 객체(mutable object)**가 있을 때입니다.

예:  
- 배열  
- List, Map 같은 컬렉션  
- StringBuilder, Date, 사용자 정의 객체 등  

이런 객체들은 내부 상태를 변경할 수 있기 때문에,  
얕은 복사 시 원본과 복제본이 함께 변경되는 문제가 발생할 수 있습니다.

---

# ❓ 9. 개발 실무에서 clone()이 비추천되는 이유는 무엇인가요?

## ✅ 답변 예시
- 기본 구현이 얕은 복사라 버그가 발생하기 쉽습니다.  
- deep copy를 직접 구현해야 해 복잡하고 실수 가능성이 많습니다.  
- 생성자를 거치지 않는 특성이 있어서 객체 불변성/캡슐화가 깨질 수 있습니다.  
- 상속 구조에서 clone 로직이 꼬이기 쉽습니다.  
실무에서는 보통 **복사 생성자**나 **정적 팩토리 메서드**가 더 선호됩니다.

---

# ❓ 10. clone()의 대안으로 어떤 방식을 추천하나요?

## ✅ 답변 예시
- **복사 생성자** (예: `new Person(otherPerson)`)  
- **정적 팩토리 메서드** (예: `Person.copyOf(otherPerson)`)  
- 필요한 경우 Builder 기반 복사  

이 방식은 명시적이고 설계가 명확해 유지보수에 유리합니다.